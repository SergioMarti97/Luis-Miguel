---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

# Differential Expressed Genes

@see: http://dputhier.github.io/jgb71e-polytech-bioinfo-app/practical/rna-seq_R/rnaseq_diff_Snf2.html

## Paquetes necesarios

```{r}
if (!require('EnhancedVolcano', quietly = TRUE)) {
   BiocManager::install('EnhancedVolcano')
}

# Instalar, si no está instalado, DESeq2: herramienta para el análisis transcriptómico aguas abajo
if (!require("DESeq2", quietly = TRUE)) {
  BiocManager::install("DESeq2")
}

```

## Adquirir datos

```{r}
# --- Datos de expresion genética ---

# El objeto que contiene toda la información esta guardado como .RDS
txi <- readRDS("../import quant/txi.RDS")
# Trabajaremos con los counts
countData <- txi$counts

# No vamos a trabajar más con txi, así que como ocupa 35MB, lo elimino de la memoria
rm(txi)

# La matriz tiene, en los nombres de las muetras, un sufijo después de una barra baja, que es el "sample ID" que se utilizó para secuenciarlo en illumina. Para que no de problemas, se van a renombrar

# Elimino el sufijo "_Sxx" de los nombres de las columnas
lNewColnames <- unlist(strsplit(colnames(countData), "_"))[seq(1, 2 * ncol(countData), 2)]

# Asigno los nuevos nombres de las columnas a la matriz
colnames(countData) <- lNewColnames

# Muestro los primeros datos
head(countData)

rm(lNewColnames)

# --- Datos clínicos ---

# Cargar la librería necesaria para leer archivos excel
library("readxl")

# Leer los datos del excel
clinicalData <- read_excel("../datos clinicos/dfClinical.xlsx")

# Muestro los primeros datos
head(clinicalData)

# Los datos de la matriz estan ordenados como si los números fuesen carácteres, por lo que voy a transformar la variable "Sample" del dataframe de los datos clínicos a carácter, y después lo ordenaré de menor a mayor
clinicalData$Samples <- as.character(clinicalData$Samples)
clinicalData <- clinicalData[order(clinicalData$Samples),]

# Elimino la columna del paciente 88 de la matriz "countData" 
countData <- countData[,colnames(countData) != "88"]

# Elimino la fila del paciente 88 en los datos clinicos
clinicalData <- clinicalData[clinicalData$Samples != "88",]

# Nos aseguramos de que hay el número correcto de muestras
ncol(countData)
nrow(clinicalData)

# Mostramos
head(countData)
head(clinicalData)

# Cargar la librería
library("DESeq2")

# Aplicar la transformación que une counts + metadados
dds <- DESeqDataSetFromMatrix(countData = round(countData), colData = clinicalData, design = ~Grade)

# Mostramos la información del objeto (es un objeto especial de DESeq2)
dds
```


## Diferential Expressed Genes

Aplicar la fución "DESeq" del paquete DESeq2 para obtener los datos del FC y el p valor. Estos datos permitirán aplicar un filtro para obtener los *differential expressed genes* o "DEGs" más relevantes.

```{r}
library(DESeq2)

# Aplicar función "DESeq"
dds <- DESeq(dds, betaPrior=FALSE)

resultsNames(dds)

res <- results(dds)

head(res)

saveRDS(res, "./differentialExpresionResults.RDS")
```

## Doble filtro

Aplicamos el doble filtro (FC y p-valor) para obtener los genes más relevantes que se expresan de forma diferente.

```{r}
# Omitimos los registros con NAs
resNotNans <- na.omit(res)

# Parámetros
# log2(FC) > 100
# p-value > 5
log2FC <- 2
pValue <- 0.05

# Filtro
filtteredResults <- resNotNans[abs(resNotNans$log2FoldChange) > log2FC, ]
filtteredResults <- filtteredResults[filtteredResults$pvalue < pValue, ]

filtteredResults

# Número de registros
nrow(filtteredResults)

saveRDS(filtteredResults, "./filtteredResults.RDS")
write.csv(filtteredResults, "./filtteredResults.CSV")

# @see: "https://rdrr.io/bioc/ReportingTools/man/makeDESeqDF.html"
dfResults <- as.data.frame(filtteredResults)

rm(resNotNans)
```

## Añadir "gen name" y "gen change"

Posiblemente, por un problema con la versión de SALMON (según Antonio), la anotación de los IDs de los genes no permite asociarlos con el gen al cual referencian. Si se modifica la parte diferente, el problema se soluciona.

Ahora vamos a obtener una tabla que servirá para asociar el ID del gen con el nombre y símbolo del gen. 

```{r}
library(EnsDb.Hsapiens.v86)

keytypes(EnsDb.Hsapiens.v86)

columns(EnsDb.Hsapiens.v86)

cols <- c("SYMBOL", "GENENAME")

# Por algún motivo, el ID del gen tiene una coletilla tipo: ".01". La base de datos
# no lo reconoce, así que es necesario eliminarlo
lTxID <- row.names(res)
lSplittedTxID <- unlist(strsplit(lTxID, "\\."))[seq(1, 2 * length(lTxID), 2)]

id2gene <- select(EnsDb.Hsapiens.v86, keys=lSplittedTxID, columns=cols, keytype="GENEID")

rm(lTxID, lSplittedTxID)
```

Añado el nombre del gen a los resultados.

```{r}
# Creo una función, porque volveré a utilizarla posteriormente
ObtainGenNames <- function(lGenIDs, id2gene) {
  genName <-
    unlist(lapply(lGenIDs, function(genid) {
      splittedGenId <- strsplit(genid, "\\.")[1]
      splittedGenId <- unlist(splittedGenId)[1]
      name <- id2gene[id2gene$GENEID == splittedGenId,]$GENENAME
      if (length(name) != 0) {
        return(name)
      } else {
        return("Not Available")
      }
    }))
  return(genName)
}

genName <- ObtainGenNames(rownames(filtteredResults), id2gene = id2gene)

# Número de transcritos que no estan asociados a ningún gen...
length(genName[genName == "Not Available"])

dfResults$`gen name` <- genName

rm(filtteredResults)
```

Para facilitar la comprensión de los resultados, se va a generar una nueva columna en el dataframe de los resultados para indicar si se reprime o se sobreexpresa el transcrito en concreto.

```{r}
# Contabilizar el número de genes sobreexpresados y reprimidos
# Sobreexpresados
nrow(dfResults[dfResults$log2FoldChange > 0,])
# Reprimidos
nrow(dfResults[dfResults$log2FoldChange < 0,])
# No cambian
nrow(dfResults[dfResults$log2FoldChange == 0,])

# También se guarda esta función porque se va utilizar más adelante
ObtainChange <- function(lLog2FC) {
  # Aquí guardo unas variables por si se quiere cambiar el texto de la variable "change".
  sOverexpressed <- "overexpressed"
  sRepressed <- "repressed"
  sNoChange <- "no change"
  
  # Generar una variable que indica si se sobreexpresa o se reprime el transcrito
  # Se genera en base al valor de la variable "log2FoldChange"
  lGenChange <- unlist(lapply(lLog2FC, function(FC) {
    if (abs(FC) > 0) {
      return(sOverexpressed)
    } else if (abs(FC) < 0) {
      return(sRepressed)
    } else {
      return(sNoChange)
    }
  }))
  
  return(lGenChange)
}

# Añadir la nueva variable al dataframe con los resultados
dfResults$`change` <- ObtainChange(dfResults$log2FoldChange)
```

Guardamos el dataframe generado con los resultados.

```{r}
# Guardar como un objeto serializado y como un csv
saveRDS(dfResults, "./dfResults.RDS")
write.csv(dfResults, "./dfResults.CSV")
```

## Volcano plot

Mostramos en forma de gráfica los resultados.

```{r}
# Usando una función por defecto
library('EnhancedVolcano')

EnhancedVolcano(res,
    lab = rownames(res),
    x = 'log2FoldChange',
    y = 'pvalue')
```
El gráfico de Volcano plot utilizando la función "EnhancedVolcano" no funciona como debería. Se va a proceder a crear el mismo gráfico con ggplot2.

```{r}
# Representando la misma gráfica pero ggplot2
library(ggplot2)
library(ggrepel)

# Para mostrar todos los puntos del volcano plot, es necesario construir un
# dataframe con toda la información

# Genero un nuevo dataframe a partir del resultado de DESeq
dfToPlot <- as.data.frame(res)
# Añadir el nombre del gen
dfToPlot$`gen name` <- ObtainGenNames(rownames(res), id2gene = id2gene)
# Añadir el "change"
lChange <- unlist(lapply(1:nrow(dfToPlot), function(iRow) {
  FC <- dfToPlot[iRow,]$log2FoldChange
  pv <- dfToPlot[iRow,]$pvalue
  
  if (is.na(FC) || is.na(pv)) {
    return("not available")
  }
  
  if (abs(FC) > log2FC && pv < pValue) {
    return("log2FC and p-value")
  } else if (abs(FC) > log2FC && pv > pValue) {
    return("log2FC")
  } else if (abs(FC) < log2FC && pv < pValue) {
    return("p-value")
  } else {
    return("no change")
  }
}))
dfToPlot$change <- lChange

# Graficar
ggplot(dfToPlot, aes(x = log2FoldChange, y = -log10(pvalue), color = change)) + 
  geom_point()

rm(dfToPlot)
```




